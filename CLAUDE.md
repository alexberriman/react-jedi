<!-- This file was auto-generated by claude-control from claude-control.json -->
<!-- Do not edit directly - changes will be overwritten -->

## Project Overview

React Jedi is a server-driven UI (SDUI) library that enables developers to build modern React interfaces using JSON specifications. It provides a single `render()` function that transforms JSON schemas into fully functional React components, leveraging TailwindCSS for styling and ShadCN components for a polished UI. The library focuses on zero lock-in architecture, allowing developers to import only what they need while supporting advanced features like reactive state management, conditional rendering, animations, and theme inheritance directly within JSON specifications.

## NPM Scripts

- `build` - Build library for production
- `test` - Run tests once
- `lint` - Check code for linting errors
- `lint:fix` - Fix linting errors
- `format` - Format code with Prettier
- `format:check` - Check code formatting
- `typecheck` - Check TypeScript types
- `check` - Run lint, typecheck, and tests
- `build-storybook` - Build Storybook for production
- `example-app` - Build library and run example app
- `example-app:build` - Build library and example app for production
- `rj-dev` - Run React Jedi CLI tool

## Functional Programming

- Use pure functions without side effects
- Prefer immutable data structures (avoid mutation)
- Favor higher-order functions and composition (`map`, `filter`, `reduce`)
- Write declarative code over imperative
- Keep utility functions testable and predictable
- Embrace currying and partial application for reuse
- Avoid deeply nested conditionals‚Äîuse early returns or extract logic
- Avoid shared mutable state‚Äîpass data explicitly

## TypeScript Guidelines

- Use explicit, precise types ‚Äî avoid `any`; prefer `unknown` if necessary
- Model data with `interface` or `type`, and use `readonly` where applicable
- Prefer `import type { X } from "pkg"` to keep value/runtime scope clean
- Use **union types**, **generics**, and **discriminated unions** for expressive modeling
- Create **branded types** for domain primitives (e.g. `UserId`, `Currency`)
- Use **template literal types** to validate structured strings
- Implement **conditional types** for flexible, reusable APIs
- Define **polymorphic components** using `as` prop and generic `ElementType`
- Enforce **strict mode** in `tsconfig.json`
- Keep types close to usage ‚Äî extract only when reused or complex

### Additional Practices

- Use `Omit`, `Pick`, `Partial`, `Required`, and mapped types for clean composition
- Prefer utility types over manual duplication
- Flatten deep type nesting ‚Äî keep type shapes maintainable
- Use `Record<K, V>` for well-defined key-value maps
- Avoid overly clever or deeply recursive types ‚Äî prioritize readability
- Use **primitive types** (`string`, `number`, `boolean`) over object types (`String`, `Number`, etc.)
- Always specify **explicit return types** for functions
- Use `void` as return type for callbacks that don't return anything
- Avoid optional parameters in callbacks unless necessary
- Place more specific overloads **before** more general ones
- Use union types instead of overloads when only parameter types vary
- Avoid declaring generics if the type parameter isn‚Äôt used

## Directory Structure

- `src/` - Library source code
  - `components/ui/` - React components (accordion, button, card, etc.)
  - `lib/` - Core library functionality
    - `accessibility/` - ARIA attributes, focus management, screen reader support
    - `animation/` - Animation hooks, providers, and transitions
    - `data/` - Data fetching and optimistic updates
    - `events/` - Event handling and delegation
    - `parser/` - JSON specification parser and validator
    - `performance/` - Memoization and state optimizations
    - `seo/` - SEO utilities, microdata, structured data
    - `state/` - State management and context
    - `theme/` - Theming system, color modes, responsive utilities
  - `hooks/` - React hooks
  - `types/` - TypeScript type definitions
  - `schemas/` - JSON schemas for components
  - `benchmark/` - Performance benchmarking
- `examples/` - Example application demonstrating library usage
- `docs/` - Documentation files
- `dist/` - Built library output

## Naming Conventions

### File Structure

- One React component per folder:  
  `index.ts`, `component-name.tsx`, `component-name.stories.tsx` (optional)
- Use `index.ts` for barrel exports (export component + types)

### File Naming

- Components: `kebab-case.tsx`
- Stories: `component-name.stories.tsx`
- Tests: `component-name.test.ts`
- Hooks: `use-xyz.ts`

### Rules

- Match filenames to exported names
- Use lowercase filenames (no PascalCase)
- Keep folders shallow and feature-based

## Function Arguments

- Prefer a single options object over multiple params
- Use explicit types and readonly where possible
- Mark optional fields with ? and provide sensible defaults
- Keep arguments immutable and self-descriptive
- Avoid boolean flags‚Äîsplit into multiple functions instead
- Avoid positional reliance‚Äîorder shouldn't matter in options

## Error Handling

- Handle errors gracefully ‚Äî never silently fail
- Use `async/await` (not `.then()`/`.catch()`)
- Prefer `try {}` / `catch {}` when the error variable isn't needed  
  _Avoid `catch (e)` if `e` is unused ‚Äî it will trigger lint errors_
- Always provide clear, descriptive error messages
- Use `ts-results` or `Result<T, E>` for structured functional error handling
- Avoid `console.error` in production code ‚Äî surface errors meaningfully

## Testing Guidelines

- Pure and utility functions **must** have matching `original-name.test.ts` files
- Place test files **in the same directory** as the code being tested
- Use **Vitest** for all unit tests
- Focus tests on **business logic**, **data transformations**, and **edge cases**
- Always test **error handling paths**
- **Mock external dependencies** only when necessary ‚Äî prefer testing real behavior
- Keep tests **small, focused, and independent**
- Use **descriptive test names** that clearly state the expected behavior
- Structure tests using **Arrange ‚Üí Act ‚Üí Assert** pattern

### Additional Rules

- ‚ùå Do **not** test trivial getters, setters, or plain constants
- ‚úÖ Prefer testing **behavior** over implementation details
- ‚ùå Avoid overly brittle tests ‚Äî changes to internals shouldn‚Äôt break a passing test

## Component Design

- One component per file (`kebab-case.tsx`)
- Use named function declarations (`function MyComponent() {}`), not arrow functions
- Create adjacent Storybook file: `component-name.stories.tsx`
- Configure stories with `tags: ['test']` to enable Vitest testing
- Name properties interface `ComponentNameProperties`
- Destructure properties with defaults at the top
- No tests required for UI/presentational components
- Use `children` and support `className`, `...properties` passthrough
- Separate smart (logic) and dumb (presentational) components
- Smart components must reuse dumb components (`<Button />` not `<button>`)
- Avoid prop drilling ‚Äî use context where needed
- Prefer composition over inheritance
- Ensure accessibility: keyboard nav, ARIA, labels

### Visual & Animation

- Components must look üî• ‚Äî clean, modern, minimal
- No glassmorphism or visual gimmicks
- Use **Framer Motion** for subtle animation, toggle via property (`animated={false}`)

### Performance

- Use `React.memo` if properties are stable
- Use `useCallback`/`useMemo` to avoid unnecessary re-renders
- Avoid inline functions/objects in JSX
- Lazy-load **non-critical** components with `React.lazy` + `Suspense`  
  _Don‚Äôt lazy-load small, frequently-used components_
- Use stable keys for lists; avoid reindexing
- Batch state updates
- Virtualize long lists when needed

### Storybook Testing

- Add `@storybook/addon-vitest` for component testing
- Tag testable stories with `tags: ['test']` in story metadata
- Stories automatically become Vitest tests running in real browsers
- Use play functions for interaction testing
- Configure in `vitest.config.ts` with browser mode enabled
- Run tests via Storybook UI or CLI (`npm run test-storybook`)

## Git Workflow

- Use mainline development (work directly on `main`, avoid feature branches)
- Follow Conventional Commits: `type: description`
- Allowed types: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`
- Write clear, concise messages that describe _what_ and _why_
- Each commit should be a logical unit of work
- Squash commits when appropriate to maintain clean history
- All commits must pass lint, typecheck, tests, and build steps
- ‚ùóÔ∏è**Never mention Claude, AI, or tooling assistance in commits** ‚Äî this is strictly prohibited

## Task Approach

When tackling any task:

- **Think very hard before writing code**  
  Carefully analyze the problem, constraints, and best practices. Use deep reasoning to plan the _best_ approach ‚Äî this step is critical.
- Break the task into small, logical, high-quality steps
- Prioritize clarity, correctness, and maintainability over speed
- Once you've thought deeply, **begin implementation immediately** ‚Äî do not output or explain the plan first
- Deliver:
  1. A robust core implementation with proper error handling
  2. Well-structured code and clean abstractions
  3. Tests for all completed functionality
  4. Safe defaults and basic security practices
- After committing and pushing the task, **stop and wait** ‚Äî do **not** move on without instruction

### Special Cases

- If building **UI components**:  
  Make them üî• ‚Äî clean, modern, elegant, and visually impressive.  
  Use **subtle, thoughtful animations** (e.g. via Framer Motion), but **ensure all animations can be toggled via a prop** (e.g. `animated={false}`).  
  **No glassmorphism or overused visual effects** ‚Äî we‚Äôre building a world-class interface.

- If building **library or utility code**:  
  Prioritize composability, reusability, and type safety. Keep functions small, pure, and well-tested. Think like a framework author.

## Dos and Don'ts

### ‚úÖ DO

- Write small, reusable, and pure functions
- Break large functions/components into smaller, focused units
- Limit to one React component per file
- Fix all ESLint and TypeScript errors properly
- Follow naming conventions consistently
- Use robust error handling (no silent failures)

### ‚ùå DON'T

- ‚ùå Do _not_ bypass Husky hooks using `--no-verify`
- ‚ùå Do _not_ use `// eslint-disable` or `// @ts-ignore` ‚Äî fix the root cause
- ‚ùå Do _not_ modify ESLint or Husky configs to suppress errors
- ‚ùå Do _not_ destructure to omit object props ‚Äî use the `omit()` utility instead